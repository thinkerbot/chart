#!/usr/bin/env ruby
begin
  require 'optparse'
  require 'chart'
  require 'sinatra'
  require 'json'

  options = {
    :chart => 'monitor',
    :transport => 'poll',
    :open => false,
    :mode => :server,
    :config_file => "/dev/null",
  }
  OptionParser.new do |opts|
    opts.banner = %{
usage: chart [options] FILES...

  Create d3 charts from data files.

options:
}.lstrip

    opts.on("-c", "--config-file CONFIG_FILE", "set configs from a file") do |value|
      options[:config_file] = value
    end

    opts.on("-e", "--echo-data", "print data and exit") do
      options[:mode] = :echo
    end

    opts.on("-h", "--help", "print this help") do
      puts opts
      puts
      puts Chart.version
      exit
    end

    opts.on("-O", "--[no-]open", "open the chart url (#{options[:open]})") do |value|
      options[:open] = value
    end

    opts.on("-t", "--chart-type TYPE", "set the chart type (#{options[:chart]})") do |value|
      options[:chart] = value
    end
  end.parse!

  DEFAULT_STYLES = {
    "monitor" => :line,
    "series"  => :file,
  }

  chart = options[:chart]
  transport = options[:transport]
  input_style = options[:input_style] || DEFAULT_STYLES[chart]
  config_file = options[:config_file]

  # Force explicit '-' to create a chart interactively.
  if ARGV.empty? && STDIN.tty?
    STDIN.close
  end

  parser = Chart::Parser.new(ARGF)
  feeder = Chart::Feeders.lookup(input_style).new(parser)

  server = Sinatra.new do
    set :app_file, __FILE__
    set :root, File.expand_path("../..", __FILE__)
    set :public_dir, settings.root + "/public"
    set :views, settings.root + "/views"
    set :method_override, true
    set :bind, "0.0.0.0"
    set :port, 4567
    set :chart, chart
    set :transport, transport
    set :feeder, feeder
    set :config_file, config_file
    set :raise_errors, true

    get('/')     { erb :"charts/#{chart}.html", :locals => {:chart => settings.chart, :transport => settings.transport} }
    get('/config') { erb :"charts/#{chart}.json.erb" }
    get('/quit') { self.class.quit! }
    get('/poll') { feeder.next_data.to_json }

    helpers do
      def base_url
        @base_url ||= "#{request.env['rack.url_scheme']}://#{request.env['HTTP_HOST']}"
      end

      def config_url
        File.join(base_url, "config")
      end

      def transport_url
        File.join(base_url, settings.transport)
      end

      def shutdown_url
        File.join(base_url, 'quit')
      end

      def config
        data = File.read(settings.config_file)
        data.empty? ? {} : JSON.load(data)
      end
    end
  end

  case options[:mode]
  when :server
    chart_url = "http://localhost:4567"
    if options[:open]
      fork do
        exec "open #{chart_url}"
      end
    end
    puts chart_url

    server.run!
  when :echo
    loop do
      data = feeder.next_data
      break if data.empty?
      puts data.to_json
    end
  end

rescue Interrupt
  exit 130
rescue Errno::EPIPE
  exit 0
end
