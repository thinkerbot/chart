#!/usr/bin/env ruby
begin
  require 'optparse'
  require 'chart'
  require 'chart/parsers'
  require 'chart/receivers'
  require 'chart/senders'
  require 'json'

  options = {
    :defaults   => [],
    :input_type => 'nxyz',
    :recvr_type => :line,
    :sendr_type => :echo,
    :null_str   => nil,
  }
  OptionParser.new do |opts|
    opts.banner = %{
usage: chart [options] FILES...

  Create d3 charts from data files.

options:

}.lstrip

    opts.on("-h", "--help", "print this help") do
      puts opts
      puts
      puts Chart.version
      exit
    end

    opts.on("-i", "--input-type TYPE", "sets input type") do |value|
      options[:input_type] = value
    end

    opts.on("-N", "--null-str STR", "sets the null str ") do |value|
      options[:null_str] = value
    end

    opts.on("-n", "--default-name NAME", "sets default name") do |value|
      options[:defaults][0] = lambda { value }
    end

    opts.on("-t", "--time-now FIELDS", "sets default for fields to now") do |value|
      value.chars.each do |c|
        i = Chart::Parser::DATA_TYPES.index(c)
        options[:defaults][i] = lambda { Time.now.utc.iso8601 }
      end
    end

    opts.on("-u", "--url URL", "sets base url") do |value|
      options[:url] = value
    end

    opts.on("-x", "--default-x VALUE", "sets default x value") do |value|
      options[:defaults][1] = lambda { value }
    end

    opts.on("-y", "--default-y VALUE", "sets default y value") do |value|
      options[:defaults][2] = lambda { value }
    end

    opts.on("-z", "--default-z VALUE", "sets default z value") do |value|
      options[:defaults][3] = lambda { value }
    end
  end.parse!

  input_type = options[:input_type]
  recvr_type = options[:recvr_type]
  sendr_type = options[:sendr_type]

  parser = Chart::Parsers.create(input_type,
    :defaults => options[:defaults],
    :null_str => options[:null_str],
  )
  recvr  = Chart::Receivers.create(recvr_type)
  sendr  = Chart::Senders.create(sendr_type,
    :url => options[:url]
  )

  while line = ARGF.gets
    line.chomp!("\n")
    nxyz    = parser.call(line)
    dataset = recvr.call(nxyz)
    sendr.call(dataset) if dataset
  end

  dataset = recvr.call(nil)
  sendr.call(dataset) if dataset

rescue Interrupt
  exit 130
rescue Errno::EPIPE
  exit 0
end
