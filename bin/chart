#!/usr/bin/env ruby
begin
  require 'optparse'
  require 'chart'
  require 'sinatra'
  require 'json'

  options = {
    :chart => 'monitor',
    :transport => 'poll',
    :open => false,
  }
  OptionParser.new do |opts|
    opts.banner = %{
usage: chart [options] FILES...

  Create d3 charts from data files.

options:
}.lstrip

    opts.on("-h", "--help", "print this help") do
      puts opts
      puts
      puts Chart.version
      exit
    end

    opts.on("-O", "--[no-]open", "open the chart url (#{options[:open]})") do |value|
      options[:open] = value
    end

    opts.on("-t", "--chart-type TYPE", "set the chart type (#{options[:chart]})") do |value|
      options[:chart] = value
    end
  end.parse!

  DEFAULT_FORMATS = {
    "monitor" => "line",
    "series"  => "csv",
  }

  chart = options[:chart]
  transport = options[:transport]
  input_format = options[:input_format] || DEFAULT_FORMATS[chart]

  # Force explicit '-' to create a chart interactively.
  if ARGV.empty? && STDIN.tty?
    STDIN.close
  end

  chart_url = "http://localhost:4567"
  if options[:open]
    fork do
      exec "open #{chart_url}"
    end
  end
  puts chart_url

  Sinatra.new do
    set :app_file, __FILE__
    set :root, File.expand_path("../..", __FILE__)
    set :public_dir, settings.root + "/public"
    set :views, settings.root + "/views"
    set :method_override, true
    set :bind, "0.0.0.0"
    set :port, 4567
    set :chart, chart
    set :transport, transport
    set :input_format, input_format
    set :raise_errors, true

    get('/')     { erb :"charts/#{chart}.html", :locals => {:chart => settings.chart, :transport => settings.transport} }
    get('/quit') { self.class.quit! }
    get('/poll') { next_data || empty_data }

    helpers do
      def empty_data
        {}.to_json
      end

      def next_data
        begin
          case settings.input_format
          when "line"
            if line = ARGF.gets
              {"data" => [line]}.to_json
            else
              nil
            end
          when "csv"
            lines = []
            while line = ARGF.gets
              lines << line.split(',')
            end
            return nil if lines.empty?

            keys = lines.shift
            lines.map! do |values|
              Hash[keys.zip(values)]
            end
            {"data" => lines}.to_json
          end
        rescue IOError
          nil
        end
      end

      def base_url
        @base_url ||= "#{request.env['rack.url_scheme']}://#{request.env['HTTP_HOST']}"
      end

      def transport_url
        File.join(base_url, settings.transport)
      end

      def shutdown_url
        File.join(base_url, 'quit')
      end
    end
  end.run!

rescue Interrupt
  exit 130
rescue Errno::EPIPE
  exit 0
end
